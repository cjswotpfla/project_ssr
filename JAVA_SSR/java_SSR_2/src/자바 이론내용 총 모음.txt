변수 
- 정수형변수의 종류
- byte
- char
- short
- int    - 주로 이거를 씀
- long
- double, float(실수형)
- boolean(논리형) - 참 또는 거짓
- String(문자열)

변수명 작성규칙 
- 숫자로 시작할 수 없다
- 예약어 사용 불가
- 특수문자 $,_만 가능
- 중복선언 불가
- 대소문자 구별함

변수명 작성 관례
- 소문자로 한다
- 상수는 대문자로
- 카멜 표기법 : 변수명이 두 단어이상으로 되어있을때 두번째 단어부터 첫글자만 대문자로
- 클래스는 첫글자는 대문자로
- 변수명/메소드/클래스명은 의미있는 단어로 작성

일반변수
- 기본타입으로 선언한 변수
- 값을 저장
- ==로 비교

참조변수
- 기본타입이 아닌 배열, 클래스, 열거형 등으로 선언
- 주소를 저장
- 클래스인 경우 equals() 이용,
  기본타입 배열은 == 이용,
  클래스 배열은 equals() 이용 

멤버변수와 매개변수의 우선순위 => 매개변수



연산자 종류
- 산술연산자
   - +.-,*,/,%
   - 정수/정수 => 정수가 되어서 소수점이 사라짐(정확하지 않음)
     타입변환을 통해 (double)정수 / 정수 => 실수가 되도록 해야함
   - % : 나머지 연산자 -> 나누었을 때 나머지를 출력
   - 산술 연산자의 계산 결과값은 값
- 대입 연산자 
   - = 
   - 오른쪽에 있는 값을 왼쪽에 저장
   - 왼쪽에는 변수가 1개 와야함
   - 저장, 덮어쓴다, 초기화 등의 표현
   - 대입 연산자는 값 또는 주소값
- 증감연산자
   - ++,--
   - 최종적으로 1 증가 또는 감소
   - 전위형 : 증가 후 동작
   - 후위형 : 동작 후 증가
   - 증감연산자 결과값은 값
- 비교연산자
   - >,<,>=,<=,==,!=
   - 크기 비교
   - 일반 변수의 크기를 비교할 때 사용
   - 비교 연산자 결과값은 참 또는 거짓(논리값)
   - ==와 대입연산자 =을 혼동하지 말자
- 논리 연산자
   - &&, ||, !
   - && : ~하고, ~이고, 둘다 참이면 참, 나머지는 거짓
   - || : ~거나, 둘다 거짓이면 거짓, 나머지는 참 
   - ! : ~아닌, 반대, 참이면 거짓, 거짓이면 참
   - 논리 연산자 결과값은 참 또는 거짓(논리값)
- 조건선택연산자
   - (조건식)?(참) : (거짓) 
   - 조건식이 참이면 (참)에 해당하는 부분을 거짓이면 (거짓)에
     해당하는 부분을 실행
- 조건식
   - 연산 결과가 참 또는 거짓이 되는 식
- 연산자 우선순위
   - 우선순위는 ()가 제일 높다

- 조건문
   - ~하면 ... 해라
   - ~ : 조건식, ... : 실행문
   - if문 : 모든 조건문을 다룰 수 있다 
   - switch문 : 사용하는 변수(식)의 값이 제한적일 때 
   - if(조건식){                        -switch(조건식){
	실행문1;		       case 값:		    	
     }else{		실행문1;		실행문1;
	실행문2;			break;(switch문 빠져나감)
     }			       default(조건식이 아니면) :
				실행문2						
			   }


- 반복문
   - 동일한 작업을 정해진 횟수만큼 혹은 무한정적으로 반복해야 
      하는 경우에 사용
   - 반복횟수, 규칙성을 찾아야 한다 
   - for( 초기화;조건식;증감식){        - while(조건식){
	실행문;			실행문;
      }
			         }
   -do{
	실행문;
     }while(조건식)
   
   - 유의사항 
      - 의도치 않은 무한루프가 생기지 않도록 주의
      - 조건식을 잘못 지정해서 실행되지 않는 경우가 생기지 않도록 주의

- 향상된 for문
   - 배열이나 리스트일 때 향상된 for문을 사용할 수 있다
   - 배열이나 리스트의 원소들을 전체 탐색할 때 사용
   - for(타입 변수명 : 배열이나 리스트) { 
	실행문 ;
     }
    -continue, break
 	- 스킵

- 배열 
   - (같은의미)같은타입 변수들의 집합
   - 변수들을 효율적으로 관리하기 위해 사용
   - 배열은 참조변수
   - 0번지부터 i-1번지까지 순차적으로 나열
   - 배열에서 번지를 잘못 사용하면 ArrayIndexOutOfBounds 예외 발생
   - 배열 길이 : 배열명.length
   - 반복문과 같이 사용됨
   - 타입 변수명[] = new 타입[(나열할 갯수)];

- 클래스
   - 메소드
       - 하나의 기능을 하도록 모아놓은 코드
       - 매개변수 : 메소드를 실행하기 위해 필요한 정보
       - 리턴타입 : 메소드 실행 후 알려주는 정보 
       - (접근제한자) 리턴타입 메소드명(매개변수){}
       - 리턴값은 해당 메소드를 호출한 메소드에게 알려줌
       - 매개변수는 값 또는 주소값을 복사해서 사용
       - 매개변수가 일반 변수인 경우 원래값(메소드를 호출한 곳에서 알려준 값)이 변경이 안됨
       - 매개변수가 참조변수인 경우 원래값이 변경될 수 있음
       - 메소드 오버로딩 

- 멤버변수 
  - 클래스에서 꼭 필요한 정보들로 설정
  - 멤버 메소드에서 멤버변수를 이용하여 동작
  - 멤버변수는 생성자에서 초기화 가능. (this.num = num;)
  - 접근제한자 타입 변수명;
  - 멤버변수가 참조변수이면 객체를 꼭 만들어 놓아야 한다.
       - 명시적 초기화 또는 생성자 또는 초기화 블록 

- 생성자 
   - 멤버변수를 초기화 하는곳
   - 일반적으로 접근제한자가 public
   - 이름이 클래스명과 동일
   - 리턴타입을 쓰지 않음
   - new를 이용하여 객체 생성 시 호출
   - 객체 생성 후 임의로 호출할 수 없음
   - 생성자 오버로딩을 통해 다양한 형태의 생성자를 만들 수 있다.
   - 생성자가 없으면 기본 생성자가 만들어짐
   - this.멤버변수 = 멤버변수;
  
- 객체 선언 및 생성
   - 클래스명 객체명 = new 클래스명();
   - 객체는 생성을 해야 멤버 메소드와 멤버 변수를 사용할 수 있음
   - 객체를 생성하지 않고 멤버 메소드와 멤버 변수를 사용하면 NullPointer 예외가 발생함

- 멤버 메소드 호출법 : 객체명.메소드명(매개변수);
 
- 접근제한자 
   - public		: 본인 + 같은 패키지 + 자식 + 다른 패키지
   - protected	: 본인 + 같은 패키지 + 자식
   - (default)	: 본인 + 같은 패키지
   - private	: 본인

- static
   - 멤버 변수/메소드를 클래스 멤버 변수/메소드로 만듬
   - 클래스 변수/메소드는 모든 객체가 공유함
   - 클래스 변수/메소드는 클래스당 1개만 존재
   - static이 안붙은 멤버 변수/메소드를 객체 멤버 변수/메소드라 함
   - 객체 변수/메소드는 각 객체마다 각각 1개씩 존재
   - 클래스 변수는 객체 메소드에서 사용할 수 있다
   - 객체 변수는 클래스 메소드 바로 에서 사용할 수 없다
   - 클래스 메소드는 객체 메소드에서 사용할 수 있다
   - 객체 메소드는 클래스 메소드에서 사용할 수 없다
   - 클래스 변수/메소드는 객체 없이 호출 가능하지만 객체 변수/메소드는 객체가 있어야 호출 가능
 
- final
   - 변할 수 없다
   - 변수	  : 상수
   - 메소드  : 오버라이딩 불가능
   - 클래스  : 부모클래스가 될 수 없음

- 상속
   - 부모클래스의 멤버변수/메소드를 물려받음 
   - A는 B이다가 성립이 될 때 가능
   - class 자식 extends 부모{}
   - 코드의 중복 제거, 쉽게 클래스 만들 수 있음
   - 서로 다른 자식 클래스의 객체들을 부모클래스가 쉽게 관리 가능
   - 부모는 한 클래스만 가능
   - 인터페이스 상속에서 부모는 여러 인터페이스가 가능
   - 메소드 오버라이딩 
      - 부모 클래스에 있는 메소드를 자식 클래스에서 재정의 하는 것
      - 부모 클래스의 메소드 선언부가 동일해야함(매개변수, 리턴타입 동일)
      - 접근제한자는 좁은 범위로 줄일 수 없다
         - 부모 클래스 메소드의 접근제한자가 public이면 해당 메소드를 자식 클래스에서 오버라이딩
           할 때 접근제한자는 public만 가능 

- 클래스 타입변환
   - 자동	      : 자식 클래스의 객체를 부모 클래스의 객체로 변환하는 경우
       	       Parent p = new Child();
   - 강제(조건) : 부모 클래스의 객체를 자식 클래스의 객체로 변환하는 경우
	       Parent p = new Child();
	       Child c = (Child)p;

- 추상클래스
   - Calendar 
   - abtract를 붙여줌
   - 추상클래스는 객체를 생성할 수 없다 - 자식 클래스를 이용하여 객체를 생성
   - 추상 메소드
      - 메소드 선언부만 있고 구현부가 없는 메소드
      - 자식클래스에서 무조건 오버라이딩을 해야함(자식클래스가 일반클래스인 경우)

- 인터페이스 
   - 상수와 추상메소드로 이루어져 있다
   - 인터페이스를 이용하여 객체를 생성할 수 없다.
   - 인터페이스를 이용하여 구현 클래스를 만든다 (implements)
   - 구현 클래스를 만들 때 여러 인터페이스를 구현해도 됨
   - 구현 클래스에서는 인터페이스에 있는 메소드들을 오버라이딩 해야함
   - 기능 명세서

- 익명 객체 
   - 클래스를 상속받아서(인터페이스를 구현해서) 이름있는 클래스로 만드는 것이 아니라
     한번 사용할 용도로 이름없는 클래스를 만들어 객체를 생성하는 것 
   - 익명 객체를 사용하는 경우 새로운 멤버 변수/메소드를 생성하지 않고 부모 클래스에 있는
     메소드나 인터페이스에 있는 메소드를 오버라이딩 해서 사용

- 예외처리
   - 프로그램이 중단되는 것을 막기 위해
   - 예외 상황을 발견하고 그 상황을 해결하기 위해
   - 예외 : 코드로 해결이 가능한 부분
   - 오류 : 코드로 해결 불가능한 부분
   - 일반 예외 : 컴파일 단계에서 확인되어 실행되지 않는 예외
                     예외처리를 하지 않으면 에러 발생
   - 실행 예외 : 컴파일 단계에서 확인되지 않고 실행과정에서 나타나는 예외,
	       예외처리를 하지 않아도 에러가 발생하지 않음
   - 참조 : NullPointer
   - 배열 : ArrayIndexOutOfBounds (번지를 잘못 접근 한 경우에 발생)
   - 나누기 : Arithmetic
   - 타입변환 : ClassCastException
   - 문자열을 숫자로 : NumberFormat
   - 예외처리 방법1 : try catch 
    try{
	예외가 발생할 수 있는 코드;               ←예외클래스명1은 예외클래스명2의 조상클래스면 안됨
     }catch(예외클래스명1 e){
	예외처리문;
     }catch(예외클래스명2 e){
 	예외처리문;
    }finally{				          ←finally는 예외처리 과정에서 메소드가 종료되도 무조건 실행
	실행문;
    }
   - 예외처리 방법2 : throws
     - 예외가 발생하면 직접 처리하지 않고 예외를 던져서 남이 처리하게 하는 방법
     - 메소드 선언부에서 매개변수 옆에 throws 예외클래스명을 입력하여 발생할 수 있는
       예외를 알려줌
     - 단 , 실행예외인 경우 throws를 생략할 수 있음
   - 예외 던지기 : throw
     - 자동으로 발생되는 예외가 아닌 변수의 조건에 따라 예외를 발생시키고자 할때 사용
     - 예외 객체를 던져야 하기 때문에 일반적으로 throw new 예외클래스명("예외메시지"); 형태로 던짐
    
- 기본 API 클래스
   - Object : 조상클래스
      - equals() : 두 객체 주소가 같은지 확인 
      - toString() : 멤버변수값을 문자열로
   - String : 문자열.
      - charAt(번지) : 문자열에서 해당 번지수에 있는 문자를 추출
      - equals() : 두 문자열이 같은지 확인
      - indexOf() : 문자열이 있는지 번지를 알려줌
      - contains() : 문자열이 있는지 확인함 
      - split() : 구분자를 기준으로 문자열을 추출하여 배열로 만듬
      - length() : 문자열의 길이를 확인 
   - Math 
      - ceil() : 올림
      - floor() : 버림
      - round(), rint() : 반올림
      - 랜덤 : random()
   - Date 
      - 날짜를 문자열로
      - 문자열을 날짜로
   - Calendar : 달력
      - 년, 월, 일, 시, 분, 초 등 다양한 값들을 확인할 수 있음
      - 추상클래스

- 제네릭 클래스 
   - 클래스의 멤버 변수 또는 메소드의 타입이 객체를 선언할 때 결정되는 클래스
   - <>로 클래스명이 필요함, 생략하면 <Object>를 한 것과 같음

- 컬렉션 프레임워크 : 인터페이스
   - 데이터를 쉽게 관리하기 위해 만들어놓은 인터페이스
   - List, Set, Map이 있음 
     - List : 순서 보장, 중복 가능
        - 구현 클래스 : ArrayList, LinkedList  
        - 향상된 for문을 이용할 수 있음
        - 멤버 메소드
        - Iterator를 이용하여 값들을 가져올 수 있다(필수가 아님)
     - Set : 중복 불가능, 순서를 보장하지 않음
        - 구현 클래스 : HashSet
        - 멤버 메소드
        - Iterator를 이용하여 반복문을 사용해야 값들을 가져올 수 있다(필수)
           -> List에 있는 get()메소드가 없기 때문
     - Map : 두 종류의 데이터를 관리 (key,value)
        - key는 중복 불가능, value는 중복 가능
        - 순서를 보장하지 않음
        - 이미 있는 key 값에 중복으로 데이터를 넣으면 최신 데이터로 덮어씀
        - 값들을 확인하기 위해 Set으로 변환시켜야 한다
             - key값을 Set으로 만들어서 확인
             - Entry라는 클래스를 이용하여  Set으로 만들어서 확인       